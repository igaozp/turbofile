# imFile 数据流与通信机制详解

## 概述

imFile 采用多层次的通信架构，包括主进程与渲染进程之间的 IPC 通信、渲染进程与 Aria2 引擎的 JSON-RPC 通信，以及应用内部的状态管理和事件传递。这种设计确保了数据的一致性、实时性和可靠性。

## 通信架构总览

```
┌─────────────────┐    IPC     ┌─────────────────┐
│   渲染进程       │ ←────────→ │    主进程        │
│ (Vue.js App)    │            │ (Node.js)       │
└─────────────────┘            └─────────────────┘
         ↓                              ↓
    JSON-RPC                    JSON-RPC/进程管理
         ↓                              ↓
┌─────────────────────────────────────────────────┐
│              Aria2 引擎进程                      │
│           (C++ 下载引擎)                        │
└─────────────────────────────────────────────────┘
```

## IPC 通信机制

### 1. IPC 消息类型

imFile 使用两种 IPC 通信模式：

#### 单向消息 (ipcMain.on / ipcRenderer.send)
```javascript
// 渲染进程 → 主进程
ipcRenderer.send('event', 'speed-change', { uploadSpeed, downloadSpeed })
ipcRenderer.send('event', 'download-status-change', downloading)
ipcRenderer.send('event', 'progress-change', progress)

// 主进程 → 渲染进程
ipcMain.emit('command', 'application:menu-about')
ipcMain.emit('command', 'application:show-add-task-dialog')
```

#### 双向调用 (ipcMain.handle / ipcRenderer.invoke)
```javascript
// 渲染进程调用主进程方法
const config = await ipcRenderer.invoke('get-app-config')
const result = await ipcRenderer.invoke('show-save-dialog', options)
const path = await ipcRenderer.invoke('show-open-dialog', options)

// 主进程响应
ipcMain.handle('get-app-config', () => {
  return configManager.getAppConfig()
})

ipcMain.handle('show-save-dialog', (event, options) => {
  return dialog.showSaveDialog(options)
})
```

### 2. IPC 组件 (Ipc.vue)

`Ipc.vue` 组件负责处理主进程发送的命令：

```vue
<template>
  <div v-if="false"></div>  <!-- 隐形组件 -->
</template>

<script>
import { commands } from '@/components/CommandManager/instance'

export default {
  name: 'mo-ipc',
  
  methods: {
    bindIpcEvents() {
      // 监听主进程发送的命令
      this.$electron.ipcRenderer.on('command', (event, command, ...args) => {
        commands.execute(command, ...args)
      })
    },
    
    unbindIpcEvents() {
      this.$electron.ipcRenderer.removeAllListeners('command')
    }
  },
  
  created() {
    this.bindIpcEvents()
  },
  
  destroyed() {
    this.unbindIpcEvents()
  }
}
</script>
```

### 3. 命令管理器 (CommandManager)

```javascript
// CommandManager/instance.js
import CommandManager from './index'

const commands = new CommandManager()

// 注册命令处理器
commands.register('application:show-add-task-dialog', (taskType) => {
  store.dispatch('app/showAddTaskDialog', taskType)
})

commands.register('application:menu-about', () => {
  store.dispatch('app/showAboutPanel')
})

commands.register('application:show-preferences', () => {
  router.push('/preference')
})

export { commands }
```

## JSON-RPC 通信机制

### 1. Aria2 客户端架构

#### 连接管理
```javascript
// api/Api.js
export default class Api {
  async init() {
    this.config = await this.loadConfig()
    this.client = this.initClient()
    this.client.open()  // 建立 WebSocket 连接
  }

  initClient() {
    const { rpcListenPort: port, rpcSecret: secret } = this.config
    return new Aria2({
      host: ENGINE_RPC_HOST,  // 127.0.0.1
      port,                   // 16800
      secret
    })
  }
}
```

#### JSON-RPC 调用示例
```javascript
// 添加下载任务
const gid = await api.client.call('addUri', [
  'http://example.com/file.zip'
], {
  dir: '/path/to/download',
  'max-connection-per-server': 16
})

// 获取任务状态
const taskInfo = await api.client.call('tellStatus', gid, [
  'gid', 'status', 'totalLength', 'completedLength',
  'downloadSpeed', 'files', 'dir'
])

// 暂停任务
await api.client.call('pause', gid)

// 获取全局统计
const stats = await api.client.call('getGlobalStat')
```

### 2. 实时事件处理

#### EngineClient 组件
`EngineClient.vue` 负责处理 Aria2 的实时事件：

```vue
<script>
export default {
  name: 'mo-engine-client',
  
  computed: {
    ...mapState('app', {
      downloadSpeed: state => state.stat.downloadSpeed,
      uploadSpeed: state => state.stat.uploadSpeed,
      downloading: state => state.stat.numActive > 0
    })
  },
  
  watch: {
    // 监听速度变化，通知主进程更新托盘
    speed(val) {
      const { uploadSpeed, downloadSpeed } = this
      this.$electron.ipcRenderer.send('event', 'speed-change', {
        uploadSpeed,
        downloadSpeed
      })
    },
    
    // 监听下载状态变化
    downloading(val, oldVal) {
      if (val !== oldVal) {
        this.$electron.ipcRenderer.send('event', 'download-status-change', val)
      }
    }
  },
  
  methods: {
    // 绑定 Aria2 事件
    bindEngineEvents() {
      if (!this.client) return
      
      this.client.on('onDownloadStart', this.onDownloadStart)
      this.client.on('onDownloadPause', this.onDownloadPause)
      this.client.on('onDownloadStop', this.onDownloadStop)
      this.client.on('onDownloadComplete', this.onDownloadComplete)
      this.client.on('onDownloadError', this.onDownloadError)
      this.client.on('onBtDownloadComplete', this.onBtDownloadComplete)
    },
    
    // 下载开始事件处理
    onDownloadStart(event) {
      const [{ gid }] = event
      
      // 更新任务列表
      this.$store.dispatch('task/fetchList')
      
      // 重置更新间隔
      this.$store.dispatch('app/resetInterval')
      
      // 保存会话
      this.$store.dispatch('task/saveSession')
      
      // 获取任务详情并记录目录
      this.fetchTaskItem({ gid }).then(task => {
        this.$store.dispatch('preference/recordHistoryDirectory', task.dir)
        
        // 显示开始通知
        if (this.taskNotification) {
          this.showTaskStartNotification(task)
        }
      })
    },
    
    // 下载完成事件处理
    onDownloadComplete(event) {
      const [{ gid }] = event
      
      this.$store.dispatch('task/fetchList')
      
      this.fetchTaskItem({ gid }).then(task => {
        // 显示完成通知
        if (this.taskNotification) {
          this.showTaskCompleteNotification(task)
        }
        
        // 播放完成音效
        this.playCompleteSound()
      })
    }
  }
}
</script>
```

## Vuex 状态管理

### 1. 状态结构

```javascript
// store/index.js
export default new Vuex.Store({
  modules: {
    app: {           // 应用全局状态
      state: {
        systemTheme: 'light',
        engineInfo: {},
        stat: {
          downloadSpeed: 0,
          uploadSpeed: 0,
          numActive: 0,
          numWaiting: 0,
          numStopped: 0
        },
        addTaskVisible: false,
        interval: 1000
      }
    },
    
    task: {          // 任务相关状态
      state: {
        currentList: 'active',
        taskList: [],
        currentTaskGid: '',
        currentTaskItem: null,
        selectedGidList: []
      }
    },
    
    preference: {    // 偏好设置状态
      state: {
        config: {}
      }
    }
  }
})
```

### 2. Actions 数据流

```javascript
// store/modules/task.js
const actions = {
  // 获取任务列表
  async fetchList({ state, commit }) {
    const { currentList } = state
    let list = []
    
    switch (currentList) {
      case 'active':
        list = await api.tellActive()
        break
      case 'waiting':
        list = await api.tellWaiting(0, 1000)
        break
      case 'stopped':
        list = await api.tellStopped(0, 1000)
        break
    }
    
    commit('UPDATE_TASK_LIST', list)
    return list
  },
  
  // 添加 URI 任务
  async addUri({ commit, dispatch }, { uris, options = {} }) {
    try {
      const gid = await api.addUri(uris, options)
      
      // 隐藏添加任务对话框
      commit('UPDATE_ADD_TASK_VISIBLE', false)
      
      // 刷新任务列表
      dispatch('fetchList')
      
      return gid
    } catch (error) {
      throw new Error(`Failed to add URI task: ${error.message}`)
    }
  },
  
  // 暂停任务
  async pauseTask({ dispatch }, gid) {
    await api.pause(gid)
    dispatch('fetchList')
  }
}
```

### 3. 状态响应式更新

```javascript
// 组件中监听状态变化
export default {
  computed: {
    ...mapState('task', ['taskList', 'currentList']),
    ...mapGetters('task', ['activeTaskCount', 'completedTaskCount'])
  },
  
  watch: {
    // 监听任务列表变化
    taskList: {
      handler(newList, oldList) {
        // 检查是否有新完成的任务
        const newCompleted = newList.filter(task => 
          task.status === 'complete' && 
          !oldList.some(old => old.gid === task.gid && old.status === 'complete')
        )
        
        // 处理新完成的任务
        newCompleted.forEach(task => {
          this.handleTaskComplete(task)
        })
      },
      deep: true
    }
  }
}
```

## 数据流转模式

### 1. 用户操作数据流

```
用户点击 → Vue 组件事件 → Vuex Action → API 调用 → Aria2 RPC
    ↑                                               ↓
界面更新 ← Vue 响应式更新 ← Vuex Mutation ← WebSocket 事件
```

#### 示例：暂停任务流程
```javascript
// 1. 用户点击暂停按钮
<el-button @click="pauseTask">暂停</el-button>

// 2. 组件方法调用
methods: {
  pauseTask() {
    this.$store.dispatch('task/pauseTask', this.task.gid)
  }
}

// 3. Vuex Action 处理
async pauseTask({ dispatch }, gid) {
  await api.pause(gid)  // 调用 Aria2 API
  dispatch('fetchList') // 刷新任务列表
}

// 4. Aria2 响应并触发事件
client.on('onDownloadPause', (event) => {
  // WebSocket 事件通知任务已暂停
  this.$store.dispatch('task/fetchList')
})
```

### 2. 实时数据更新流程

```
Aria2 引擎 → WebSocket 事件 → EngineClient 组件 → Vuex Action → 组件更新
```

#### 定时轮询机制
```javascript
// EngineClient.vue
export default {
  data() {
    return {
      timer: null,
      interval: 1000
    }
  },
  
  methods: {
    startPolling() {
      this.timer = setInterval(() => {
        // 获取全局统计
        this.fetchGlobalStat()
        
        // 根据页面状态获取相应数据
        if (this.$route.name === 'task') {
          this.$store.dispatch('task/fetchList')
        }
        
        // 获取任务详情（如果详情面板打开）
        if (this.taskDetailVisible && this.currentTaskGid) {
          this.fetchTaskDetail(this.currentTaskGid)
        }
      }, this.interval)
    },
    
    // 动态调整轮询间隔
    adjustInterval() {
      const { numActive, numWaiting } = this.stat
      
      if (numActive === 0 && numWaiting === 0) {
        // 无活动任务时降低频率
        this.interval = Math.min(this.interval * 1.5, 10000)
      } else {
        // 有活动任务时恢复正常频率
        this.interval = 1000
      }
    }
  }
}
```

## 错误处理与容错机制

### 1. API 调用错误处理

```javascript
// api/Api.js
export default class Api {
  async call(method, ...params) {
    try {
      return await this.client.call(method, ...params)
    } catch (error) {
      console.error(`API call failed: ${method}`, error)
      
      // 根据错误类型进行处理
      if (error.code === 'ECONNREFUSED') {
        // 连接被拒绝，可能是引擎未启动
        this.emit('engine-disconnected')
      } else if (error.code === 'TIMEOUT') {
        // 超时错误，重试
        return this.retryCall(method, ...params)
      }
      
      throw error
    }
  }
  
  async retryCall(method, ...params, retryCount = 3) {
    for (let i = 0; i < retryCount; i++) {
      try {
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)))
        return await this.client.call(method, ...params)
      } catch (error) {
        if (i === retryCount - 1) throw error
      }
    }
  }
}
```

### 2. 连接状态管理

```javascript
// EngineClient.vue
export default {
  data() {
    return {
      connected: false,
      reconnectTimer: null,
      maxReconnectAttempts: 5,
      reconnectAttempts: 0
    }
  },
  
  methods: {
    handleDisconnect() {
      this.connected = false
      this.stopPolling()
      
      // 尝试重连
      this.attemptReconnect()
    },
    
    attemptReconnect() {
      if (this.reconnectAttempts >= this.maxReconnectAttempts) {
        this.showConnectionError()
        return
      }
      
      this.reconnectTimer = setTimeout(() => {
        this.reconnectAttempts++
        this.connect()
      }, 2000 * this.reconnectAttempts)
    },
    
    handleConnect() {
      this.connected = true
      this.reconnectAttempts = 0
      this.startPolling()
      
      if (this.reconnectTimer) {
        clearTimeout(this.reconnectTimer)
        this.reconnectTimer = null
      }
    }
  }
}
```

### 3. 数据一致性保证

```javascript
// store/modules/task.js
const mutations = {
  UPDATE_TASK_LIST(state, taskList) {
    // 保持选中状态的一致性
    const validGids = taskList.map(task => task.gid)
    state.selectedGidList = state.selectedGidList.filter(gid => 
      validGids.includes(gid)
    )
    
    // 更新任务列表
    state.taskList = taskList
  },
  
  UPDATE_TASK_ITEM(state, taskItem) {
    // 原子更新单个任务项
    const index = state.taskList.findIndex(task => task.gid === taskItem.gid)
    if (index !== -1) {
      Vue.set(state.taskList, index, taskItem)
    }
  }
}
```

## 性能优化

### 1. 数据缓存

```javascript
// api/Api.js
export default class Api {
  constructor() {
    this.cache = new Map()
    this.cacheTimeout = 5000 // 5秒缓存
  }
  
  async fetchTaskItem({ gid, useCache = true }) {
    const cacheKey = `task-${gid}`
    
    if (useCache && this.cache.has(cacheKey)) {
      const { data, timestamp } = this.cache.get(cacheKey)
      if (Date.now() - timestamp < this.cacheTimeout) {
        return data
      }
    }
    
    const data = await this.tellStatus(gid)
    this.cache.set(cacheKey, { data, timestamp: Date.now() })
    
    return data
  }
}
```

### 2. 请求合并

```javascript
// 批量获取任务状态
async batchFetchTasks(gids) {
  const calls = gids.map(gid => ['tellStatus', gid, [
    'gid', 'status', 'totalLength', 'completedLength'
  ]])
  
  return this.client.batch(calls)
}
```

### 3. 防抖处理

```javascript
// utils/debounce.js
export function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// 在组件中使用
methods: {
  fetchList: debounce(function() {
    this.$store.dispatch('task/fetchList')
  }, 300)
}
```

这种多层次的通信架构确保了 imFile 应用的数据流转高效、可靠，同时具备良好的容错能力和性能表现。通过合理的状态管理、错误处理和性能优化，应用能够在各种网络条件下稳定运行。